{
	// This file should be current for the latest revision of the ISO C standard
	// as of this writing (late 2004 -- C99).  If one chooses to be pedantic,
	// this might be further broken out into a "base C" file with different
	// "subclass" syntaxes for C90 and C99. C++ would then inherit from the "base C"
	// syntax, which would avoid the C99 non-C++ keywords. But this seems more
	// pragmatic. -- chris.
	
	name = "C";
	keyEquivalent = "~^C";
	scopeName = "source.c";
	fileTypes = ( c, h );
	foldingStartMarker = "(/\\*\\*|\\{\\s*$)";
	foldingStopMarker = "(\\*\\*/|^\\s*\\})";
	patterns = (
		{ name = "comment.block.c"; begin = "/\\*"; end = "\\*/"; },
		{ name = "comment.line.double-slash.c++"; begin = "//"; end = "$"; swallow = "\\\\\\s*\\n"; },
		{ name = "keyword.control.c"; match = "\\b(break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|while)\\b"; },
		{ name = "storage.type.c"; match = "\\b(asm|__asm__|auto|_Bool|char|_Complex|double|enum|float|_Imaginary|int|long|short|signed|struct|typedef|union|unsigned|void)\\b"; },
        { name = "storage.modifier.c"; match = "\\b(const|extern|register|restrict|static|volatile|inline)\\b"; },
        { name = "constant.language"; match = "\\b(NULL|true|false|TRUE|FALSE)\\b"; },
        { name = "support.function.c"; match = "\\b(sizeof)\\b"; },
		{ name = "constant.numeric.c"; match = "\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b";},
		{ name = "string.quoted.double.c"; begin = "\""; end = "\""; swallow = "\\\\."; },
		{ name = "string.quoted.single.c"; begin = "'"; end = "'"; swallow = "\\\\."; },
		{ name = "other.preprocessor.c";
		  match = "^\\s*#\\s*(define|defined|else|elif|endif|error|if|ifdef|ifndef|line|pragma|undef|warning)\\b";
			captures = { 1 = { name = "entity.name.preprocessor.c"; }; };
		},
		{ name = "other.preprocessor.c.include";
		    begin = "^\\s*#\\s*(include|import)\\b\\s+";
		    end = "$";
			captures = { 1 = { name = "entity.name.preprocessor.include.c"; }; };
		},
		
		
		{   name = "declaration.section";
    		match = "^\\s*(#\\s*(pragma\\s+mark)\\s+(.*))";
			captures = { 1 = { name = "other.preprocessor.c"; };
            			 2 = { name = "entity.name.preprocessor.pragma.c"; };
            			 3 = { name = "entity.name.section"; };
			 };
		},
		
		// This is a horrible hack. It doesn't work for functions with names smaller than four characters.
		// Comments in the wrong place, though legal C, can fool it.
		// Some function calls can fool it.
		// Various C++ constructs can fool it.
		// Macros can easily fool it. Macros can easily fool most parsers, though.
/*		{ name = "declaration.function.c";
//		    match = "(?!\\b(?:if|do|while|switch|for)\\b)([A-Za-z][A-Za-z0-9:]{4,})\\s*\\(.*?\\)(?!\\s*[;,\\(])";
            match = "(?!\\b(?:if|do|while|switch|for)\\b)([A-Za-z][A-Za-z0-9:]{4,})\\s*\\((?=.*\\)\\s*($|\\{))";
		    captures = { 1 = { name = "name"; }; };
		},
*/	);
	uuid = "25066DC2-6B1D-11D9-9D5B-000D93589AF6";
}
